-- src/database/schema.sql (Updated for v1.0 Spec)
-- HighPay MVP Database Schema

-- Companies table - No changes
CREATE TABLE companies (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    address TEXT,
    phone VARCHAR(20),
    email VARCHAR(255),
    tax_id VARCHAR(50),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Job Roles table - Renamed 'title' to 'role_name'
CREATE TABLE job_roles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
    role_name VARCHAR(255) NOT NULL, -- Renamed from 'title'
    hourly_rate DECIMAL(10,2) NOT NULL,
    overtime_rate DECIMAL(10,2),
    description TEXT,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Users table - Renamed 'role_type' to 'permission_role' and updated CHECK constraint
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
    job_role_id UUID REFERENCES job_roles(id) ON DELETE SET NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    phone VARCHAR(20),
    address TEXT,
    hire_date DATE,
    permission_role VARCHAR(50) NOT NULL CHECK (permission_role IN ('Head Management', 'Employee')), -- Renamed and updated
    is_active BOOLEAN DEFAULT true,
    fcm_token VARCHAR(500),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Time Punches table - Renamed 'punch_time' to 'timestamp' and updated punch_type ENUM
CREATE TABLE time_punches (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    punch_type VARCHAR(20) NOT NULL CHECK (punch_type IN ('CLOCK_IN', 'LUNCH_START', 'LUNCH_END', 'CLOCK_OUT')), -- Updated values
    timestamp TIMESTAMP WITH TIME ZONE NOT NULL, -- Renamed from 'punch_time'
    location_lat DECIMAL(10, 8),
    location_lng DECIMAL(11, 8),
    notes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Payrolls table - No changes
CREATE TABLE payrolls (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    company_id UUID NOT NULL REFERENCES companies(id) ON DELETE CASCADE,
    pay_period_start DATE NOT NULL,
    pay_period_end DATE NOT NULL,
    pay_date DATE NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'processing' CHECK (status IN ('processing', 'completed', 'cancelled')),
    total_amount DECIMAL(12,2) DEFAULT 0,
    employee_count INTEGER DEFAULT 0,
    processed_by UUID REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Pay Stubs table - No changes
CREATE TABLE pay_stubs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    payroll_id UUID NOT NULL REFERENCES payrolls(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    pay_period_start DATE NOT NULL,
    pay_period_end DATE NOT NULL,
    pay_date DATE NOT NULL,
    regular_hours DECIMAL(5,2) DEFAULT 0,
    overtime_hours DECIMAL(5,2) DEFAULT 0,
    regular_pay DECIMAL(10,2) DEFAULT 0,
    overtime_pay DECIMAL(10,2) DEFAULT 0,
    gross_pay DECIMAL(10,2) DEFAULT 0,
    federal_tax DECIMAL(10,2) DEFAULT 0,
    state_tax DECIMAL(10,2) DEFAULT 0,
    social_security DECIMAL(10,2) DEFAULT 0,
    medicare DECIMAL(10,2) DEFAULT 0,
    total_deductions DECIMAL(10,2) DEFAULT 0,
    net_pay DECIMAL(10,2) DEFAULT 0,
    pdf_url VARCHAR(500),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Indexes for performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_company_id ON users(company_id);
CREATE INDEX idx_time_punches_user_id ON time_punches(user_id);
CREATE INDEX idx_time_punches_timestamp ON time_punches(timestamp); -- Updated
CREATE INDEX idx_pay_stubs_user_id ON pay_stubs(user_id);
CREATE INDEX idx_pay_stubs_payroll_id ON pay_stubs(payroll_id);

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Triggers to auto-update updated_at
CREATE TRIGGER update_companies_updated_at BEFORE UPDATE ON companies FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_job_roles_updated_at BEFORE UPDATE ON job_roles FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
CREATE TRIGGER update_payrolls_updated_at BEFORE UPDATE ON payrolls FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```javascript
// src/routes/auth.js (Updated for v1.0 Onboarding)
const express = require('express');
const bcrypt = require('bcryptjs');
const db = require('../database/connection');
const { generateToken } = require('../utils/jwt');
const { body } = require('express-validator');
const { handleValidationErrors } = require('../utils/validation');
const { authenticateToken } = require('../middleware/auth');

const router = express.Router();

// Updated validation for new onboarding flow
const validateRegistration = [
    body('email').isEmail().normalizeEmail(),
    body('password').isLength({ min: 6 }).withMessage('Password must be at least 6 characters'),
    body('firstName').trim().notEmpty().withMessage('Your first name is required'),
    body('lastName').trim().notEmpty().withMessage('Your last name is required'),
    body('companyName').trim().notEmpty().withMessage('Company name is required'),
    handleValidationErrors
];

// POST /api/v1/auth/register - New Onboarding Flow (User Story 1.1)
router.post('/register', validateRegistration, async (req, res) => {
    const { email, password, firstName, lastName, companyName } = req.body;
    const client = await db.pool.connect();

    try {
        await client.query('BEGIN');

        // Check if user email already exists
        const existingUser = await client.query('SELECT id FROM users WHERE email = $1', [email]);
        if (existingUser.rows.length > 0) {
            return res.status(409).json({ success: false, error: { code: 'EMAIL_EXISTS', message: 'Email already registered.' } });
        }

        // 1. Create the Company
        const companyResult = await client.query(
            `INSERT INTO companies (name) VALUES ($1) RETURNING id`,
            [companyName]
        );
        const companyId = companyResult.rows[0].id;

        // 2. Hash password
        const passwordHash = await bcrypt.hash(password, 12);

        // 3. Create the "Head Management" User
        const userResult = await client.query(`
            INSERT INTO users (company_id, email, password_hash, first_name, last_name, permission_role)
            VALUES ($1, $2, $3, $4, $5, 'Head Management')
            RETURNING id, email, first_name, last_name, permission_role
        `, [companyId, email, passwordHash, firstName, lastName]);
        
        const user = userResult.rows[0];
        
        await client.query('COMMIT');
        
        // 4. Generate token and log the user in
        const token = generateToken(user.id, user.email, user.permission_role);

        res.status(201).json({
            success: true,
            data: {
                token,
                user: {
                    id: user.id,
                    email: user.email,
                    firstName: user.first_name,
                    lastName: user.last_name,
                    role: user.permission_role,
                    companyId: companyId
                }
            }
        });

    } catch (error) {
        await client.query('ROLLBACK');
        console.error('Registration error:', error);
        res.status(500).json({ success: false, error: { code: 'REGISTRATION_FAILED', message: 'Failed to create account.' } });
    } finally {
        client.release();
    }
});


// POST /api/v1/auth/login (Updated to use 'permission_role')
router.post('/login', [ body('email').isEmail().normalizeEmail(), body('password').exists(), handleValidationErrors ], async (req, res) => {
    // ... (Login logic is largely the same, but references permission_role)
    try {
        const { email, password } = req.body;
        const result = await db.query(`
            SELECT u.*, c.name as company_name, jr.role_name as job_title 
            FROM users u
            LEFT JOIN companies c ON u.company_id = c.id
            LEFT JOIN job_roles jr ON u.job_role_id = jr.id
            WHERE u.email = $1 AND u.is_active = true
        `, [email]);

        if (result.rows.length === 0) {
            return res.status(401).json({ success: false, error: { code: 'INVALID_CREDENTIALS', message: 'Invalid email or password.' } });
        }
        const user = result.rows[0];
        const isValidPassword = await bcrypt.compare(password, user.password_hash);
        if (!isValidPassword) {
            return res.status(401).json({ success: false, error: { code: 'INVALID_CREDENTIALS', message: 'Invalid email or password.' } });
        }

        const token = generateToken(user.id, user.email, user.permission_role);

        res.json({
            success: true,
            data: {
                token,
                user: {
                    id: user.id,
                    email: user.email,
                    firstName: user.first_name,
                    lastName: user.last_name,
                    role: user.permission_role,
                    companyId: user.company_id,
                    companyName: user.company_name,
                    jobTitle: user.job_title
                }
            }
        });
    } catch (error) {
        console.error('Login error:', error);
        res.status(500).json({ success: false, error: { code: 'LOGIN_FAILED', message: 'Failed to authenticate.' } });
    }
});


// GET /api/v1/auth/me (No major changes needed, but will reflect new column names)
router.get('/me', authenticateToken, async (req, res) => {
    // req.user is already populated by the middleware with the latest data
    res.json({ success: true, data: { user: req.user } });
});

module.exports = router;
```javascript
// src/middleware/auth.js (Updated to use 'permission_role')
const jwt = require('jsonwebtoken');
const db = require('../database/connection');

const authenticateToken = async (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (!token) {
        return res.status(401).json({ success: false, error: { code: 'NO_TOKEN', message: 'Access token required.' } });
    }

    try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        // Updated query to use new column names
        const userResult = await db.query(`
            SELECT u.*, c.name as company_name, jr.role_name as job_title 
            FROM users u
            LEFT JOIN companies c ON u.company_id = c.id
            LEFT JOIN job_roles jr ON u.job_role_id = jr.id
            WHERE u.id = $1 AND u.is_active = true
        `, [decoded.userId]);

        if (userResult.rows.length === 0) {
            return res.status(401).json({ success: false, error: { code: 'INVALID_TOKEN', message: 'User not found or inactive.' } });
        }
        req.user = userResult.rows[0];
        next();
    } catch (error) {
        return res.status(403).json({ success: false, error: { code: 'INVALID_TOKEN', message: 'Invalid or expired token.' } });
    }
};

const requireRole = (roles) => {
    return (req, res, next) => {
        if (!req.user) {
            return res.status(401).json({ success: false, error: { code: 'UNAUTHORIZED', message: 'Authentication required.' } });
        }
        // Updated to check 'permission_role'
        if (!roles.includes(req.user.permission_role)) {
            return res.status(403).json({
                success: false,
                error: {
                    code: 'FORBIDDEN',
                    message: 'Insufficient permissions.',
                    details: { requiredRoles: roles, userRole: req.user.permission_role }
                }
            });
        }
        next();
    };
};

module.exports = { authenticateToken, requireRole };
```javascript
// src/routes/timePunches.js (Updated for v1.0 Spec)
const express = require('express');
const { body } = require('express-validator');
const db = require('../database/connection');
const { authenticateToken, requireRole } = require('../middleware/auth');
const { handleValidationErrors } = require('../utils/validation');

const router = express.Router();

// Updated validation to use new punch types
const validateTimePunchCreation = [
    body('type').isIn(['CLOCK_IN', 'LUNCH_START', 'LUNCH_END', 'CLOCK_OUT']).withMessage('Invalid punch type.'),
    body('timestamp').isISO8601().withMessage('Timestamp must be a valid ISO 8601 date.'),
    handleValidationErrors
];

// POST /api/v1/time-punches (User Story 5.1)
router.post('/', authenticateToken, validateTimePunchCreation, async (req, res) => {
    try {
        const { type, timestamp, location, notes } = req.body;
        const result = await db.query(`
            INSERT INTO time_punches (user_id, punch_type, timestamp, location_lat, location_lng, notes)
            VALUES ($1, $2, $3, $4, $5, $6)
            RETURNING id, user_id, punch_type, timestamp
        `, [
            req.user.id, type, timestamp,
            location ? location.latitude : null,
            location ? location.longitude : null,
            notes
        ]);
        res.status(201).json({ success: true, data: result.rows[0] });
    } catch (error) {
        console.error('Create time punch error:', error);
        res.status(500).json({ success: false, error: { code: 'SERVER_ERROR', message: 'Failed to record time punch.' } });
    }
});

// GET /api/v1/time-punches/today (User Story 5.2 - Updated Logic)
router.get('/today', authenticateToken, async (req, res) => {
    try {
        const userId = req.user.id;
        const todayStart = new Date();
        todayStart.setHours(0, 0, 0, 0);
        const todayEnd = new Date();
        todayEnd.setHours(23, 59, 59, 999);

        const result = await db.query(`
            SELECT id, punch_type, timestamp FROM time_punches
            WHERE user_id = $1 AND timestamp >= $2 AND timestamp <= $3
            ORDER BY timestamp ASC
        `, [userId, todayStart, todayEnd]);

        const punches = result.rows;
        let totalWorkMs = 0;
        let lunchMs = 0;
        let clockInTime = null;
        let lunchStartTime = null;
        let lastStatus = 'CLOCK_OUT';

        punches.forEach(punch => {
            const punchTime = new Date(punch.timestamp);
            lastStatus = punch.punch_type;

            if (punch.punch_type === 'CLOCK_IN') {
                clockInTime = punchTime;
            } else if (punch.punch_type === 'LUNCH_START' && clockInTime) {
                lunchStartTime = punchTime;
            } else if (punch.punch_type === 'LUNCH_END' && lunchStartTime) {
                lunchMs += (punchTime - lunchStartTime);
                lunchStartTime = null; // Reset for next lunch break
            } else if (punch.punch_type === 'CLOCK_OUT' && clockInTime) {
                totalWorkMs += (punchTime - clockInTime);
                clockInTime = null; // Reset for next shift
            }
        });
        
        // If still clocked in, calculate hours up to now
        if (clockInTime) {
            totalWorkMs += (new Date() - clockInTime);
        }

        const totalHours = Math.round(((totalWorkMs - lunchMs) / (1000 * 60 * 60)) * 100) / 100;
        
        res.json({
            success: true,
            data: {
                punches: punches,
                totalHours: Math.max(0, totalHours), // Ensure it's not negative
                status: lastStatus
            }
        });

    } catch (error) {
        console.error("Get today's punches error:", error);
        res.status(500).json({ success: false, error: { code: 'SERVER_ERROR', message: "Failed to fetch today's time punches." } });
    }
});


// GET /api/v1/time-punches/user/:id (Updated with new roles)
router.get('/user/:id', authenticateToken, requireRole(['Head Management']), async (req, res) => {
    try {
        const { id: userId } = req.params;
        const { startDate, endDate } = req.query;
        
        let query = `
            SELECT tp.id, tp.punch_type, tp.timestamp, tp.notes 
            FROM time_punches tp
            JOIN users u ON tp.user_id = u.id
            WHERE tp.user_id = $1 AND u.company_id = $2
        `;
        const params = [userId, req.user.company_id];
        let paramCount = 2;
        if (startDate) query += ` AND tp.timestamp >= $${++paramCount}`, params.push(startDate);
        if (endDate) query += ` AND tp.timestamp <= $${++paramCount}`, params.push(endDate);
        query += ' ORDER BY tp.timestamp DESC';
        const result = await db.query(query, params);
        res.json({ success: true, data: { punches: result.rows } });
    } catch (error) {
        console.error('Get user punch history error:', error);
        res.status(500).json({ success: false, error: { code: 'SERVER_ERROR', message: "Failed to fetch user's punch history." } });
    }
});

module.exports = router;
```javascript
// src/routes/jobRoles.js (Updated for v1.0 Spec)
const express = require('express');
const { body } = require('express-validator');
const db = require('../database/connection');
const { authenticateToken, requireRole } = require('../middleware/auth');
const { handleValidationErrors } = require('../utils/validation');

const router = express.Router();

// Updated validation to use role_name
const validateJobRole = [
  body('roleName').trim().notEmpty().withMessage('Job role name is required.'),
  body('hourlyRate').isFloat({ gt: 0 }).withMessage('Hourly rate must be a positive number.'),
  handleValidationErrors
];

// GET /api/v1/job-roles
router.get('/', authenticateToken, async (req, res) => {
    // Logic is mostly the same, just updating column names
    const result = await db.query(`
        SELECT id, role_name, hourly_rate FROM job_roles WHERE company_id = $1 AND is_active = true ORDER BY role_name ASC
    `, [req.user.company_id]);
    res.json({ success: true, data: { jobRoles: result.rows } });
});

// POST /api/v1/job-roles (User Story 1.2)
router.post('/', authenticateToken, requireRole(['Head Management']), validateJobRole, async (req, res) => {
    const { roleName, hourlyRate } = req.body;
    const result = await db.query(`
        INSERT INTO job_roles (company_id, role_name, hourly_rate, overtime_rate) VALUES ($1, $2, $3, $4) RETURNING *
    `, [req.user.company_id, roleName, hourlyRate, hourlyRate * 1.5]);
    res.status(201).json({ success: true, data: { jobRole: result.rows[0] } });
});

// PUT /api/v1/job-roles/:id (User Story 1.2)
router.put('/:id', authenticateToken, requireRole(['Head Management']), async (req, res) => {
    const { id } = req.params;
    const { roleName, hourlyRate } = req.body; // Can update name or rate
    const result = await db.query(`
        UPDATE job_roles SET role_name = $1, hourly_rate = $2, overtime_rate = $3 WHERE id = $4 AND company_id = $5 RETURNING *
    `, [roleName, hourlyRate, hourlyRate * 1.5, id, req.user.company_id]);
    res.json({ success: true, data: { jobRole: result.rows[0] } });
});

module.exports = router;
```javascript
// src/routes/users.js (Updated for v1.0 Spec)
const express = require('express');
const db = require('../database/connection');
const { authenticateToken, requireRole } = require('../middleware/auth');
const { body } = require('express-validator');
const { handleValidationErrors } = require('../utils/validation');

const router = express.Router();

// Validation for adding a new employee (User Story 1.3)
const validateNewEmployee = [
    body('email').isEmail().normalizeEmail(),
    body('firstName').trim().notEmpty(),
    body('lastName').trim().notEmpty(),
    body('jobRoleId').isUUID().withMessage('A valid job role must be selected.'),
    handleValidationErrors
];

// POST /api/v1/users - Create new employee (User Story 1.3)
router.post('/', authenticateToken, requireRole(['Head Management']), validateNewEmployee, async (req, res) => {
    const { email, firstName, lastName, jobRoleId } = req.body;
    const { company_id } = req.user;
    
    // Create user with a temporary password they can reset later
    const tempPassword = `temp_pass_${Date.now()}`;
    const passwordHash = await require('bcryptjs').hash(tempPassword, 12);
    
    const result = await db.query(`
        INSERT INTO users (company_id, email, password_hash, first_name, last_name, job_role_id, permission_role)
        VALUES ($1, $2, $3, $4, $5, $6, 'Employee')
        RETURNING id, email, first_name, last_name
    `, [company_id, email, passwordHash, firstName, lastName, jobRoleId]);
    
    res.status(201).json({ success: true, data: { user: result.rows[0] } });
});

// GET /api/v1/users (User Story 3.1) - Updated with new roles
router.get('/', authenticateToken, requireRole(['Head Management']), async (req, res) => {
    const result = await db.query(`
        SELECT u.id, u.first_name, u.last_name, u.email, jr.role_name
        FROM users u
        LEFT JOIN job_roles jr ON u.job_role_id = jr.id
        WHERE u.company_id = $1
    `, [req.user.company_id]);
    res.json({ success: true, data: { users: result.rows } });
});

// PUT /api/v1/users/:id (User Story 3.2) - Updated
router.put('/:id', authenticateToken, requireRole(['Head Management']), async (req, res) => {
    const { id } = req.params;
    const { email, firstName, lastName, jobRoleId } = req.body;
    const result = await db.query(`
        UPDATE users SET email = $1, first_name = $2, last_name = $3, job_role_id = $4
        WHERE id = $5 AND company_id = $6
        RETURNING id, email, first_name, last_name
    `, [email, firstName, lastName, jobRoleId, id, req.user.company_id]);
    res.json({ success: true, data: { user: result.rows[0] } });
});


module.exports = router;
```javascript
// src/routes/payroll.js (Updated for v1.0 Spec)
const express = require('express');
const db = require('../database/connection');
const { authenticateToken, requireRole } = require('../middleware/auth');
const { sendPaydayNotification } = require('../services/pushNotificationService');
const router = express.Router();

// POST /api/v1/payroll/run (User Story 2.1) - Now uses correct role
router.post('/run', authenticateToken, requireRole(['Head Management']), async (req, res) => {
    const { payPeriodStart, payPeriodEnd, payDate } = req.body;
    const client = await db.pool.connect();
    try {
        await client.query('BEGIN');
        
        // MVP focuses on simple payroll run, so we'll mock some data as per the spec
        // and create the record. A full implementation would be more complex.
        const totalCostMock = Math.floor(Math.random() * (75000 - 45000 + 1) + 45000); // Random total between 45k-75k

        const payrollResult = await client.query(`
            INSERT INTO payrolls (company_id, pay_period_start, pay_period_end, pay_date, status, total_amount, processed_by)
            VALUES ($1, $2, $3, $4, 'COMPLETED', $5, $6)
            RETURNING id, total_amount, status
        `, [req.user.company_id, payPeriodStart, payPeriodEnd, payDate, totalCostMock, req.user.id]);
        
        // In a real scenario, we would loop through employees and trigger notifications here.
        // For the MVP, the notification trigger logic remains ready.
        
        await client.query('COMMIT');
        res.status(201).json({ success: true, data: payrollResult.rows[0] });

    } catch(error) {
        await client.query('ROLLBACK');
        console.error('Payroll Run Error:', error);
        res.status(500).json({ success: false, error: { code: 'PAYROLL_RUN_FAILED' } });
    } finally {
        client.release();
    }
});

// GET /api/v1/payroll/history (User Story 4.1)
router.get('/history', authenticateToken, requireRole(['Head Management']), async (req, res) => {
    const result = await db.query(`
        SELECT id, pay_period_start, pay_period_end, pay_date, total_amount as total_cost
        FROM payrolls WHERE company_id = $1 AND status = 'COMPLETED' ORDER BY pay_date DESC
    `, [req.user.company_id]);
    res.json({ success: true, data: { payrolls: result.rows } });
});

module.exports = router;
